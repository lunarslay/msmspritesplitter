<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>sprite extractor msm</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0e0e11;
      color: #e6e6eb;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 32px;
    }

    h1 { font-size: 28px; margin-bottom: 8px; }
    h2 { font-size: 18px; margin: 16px 0 8px; }

    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
    }

    .tab {
      padding: 10px 16px;
      border-radius: 10px;
      background: #1b1b24;
      cursor: pointer;
      opacity: .6;
    }

    .tab.active {
      opacity: 1;
      background: #6a7cff;
    }

    .card {
      background: #15151c;
      border-radius: 14px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    }

    .hidden { display: none; }

    .dropzone {
      border: 2px dashed #2d2d3a;
      border-radius: 12px;
      padding: 30px;
      text-align: center;
      cursor: pointer;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .preview {
      max-height: 360px;
      overflow: auto;
      border-radius: 10px;
      background: #0b0b10;
      padding: 10px;
      font-size: 12px;
    }

    button {
      border: none;
      background: linear-gradient(135deg, #6a7cff, #8f9bff);
      color: #fff;
      padding: 10px 18px;
      border-radius: 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Sprite Sheet Extractor</h1>

  <div class="tabs">
    <div class="tab active" data-tab="msm">MSM (TexturePacker XML)</div>
    <div class="tab" data-tab="dof">DOF (Unity .meta)</div>
  </div>

  <!-- MSM TAB -->
  <div id="msm" class="tabpage">
    <div class="card">
      <div class="row">
        <div>
          <h2>Sprite Sheet (PNG / AVIF)</h2>
          <div id="msmImgDrop" class="dropzone">Drag sprite sheets here</div>
          <input type="file" id="msmImgInput" accept="image/png,image/avif" multiple hidden>
          <div id="msmImgPreview" class="preview"></div>
        </div>
        <div>
          <h2>TexturePacker XML</h2>
          <div id="msmXmlDrop" class="dropzone">Drag XML files here</div>
          <input type="file" id="msmXmlInput" accept=".xml" multiple hidden>
          <div id="msmXmlPreview" class="preview"></div>
        </div>
      </div>
    </div>
    <button id="msmExport">Export ZIP</button>
  </div>

  <!-- DOF TAB -->
  <div id="dof" class="tabpage hidden">
    <div class="card">
      <div class="row">
        <div>
          <h2>Sprite Sheet (PNG / AVIF)</h2>
          <div id="dofImgDrop" class="dropzone">Drag sprite sheet here</div>
          <input type="file" id="dofImgInput" accept="image/png,image/avif" hidden>
          <div id="dofImgPreview" class="preview"></div>
        </div>
        <div>
          <h2>Unity .meta file</h2>
          <div id="dofMetaDrop" class="dropzone">Drag .meta here</div>
          <input type="file" id="dofMetaInput" accept=".meta" hidden>
          <div id="dofMetaPreview" class="preview"></div>
        </div>
      </div>
    </div>
    <button id="dofExport">Export ZIP</button>
  </div>
</div>

<canvas id="canvas" class="hidden"></canvas>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
/******** TABS ********/
document.querySelectorAll('.tab').forEach(t => {
  t.onclick = () => {
    document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
    document.querySelectorAll('.tabpage').forEach(x => x.classList.add('hidden'));
    t.classList.add('active');
    document.getElementById(t.dataset.tab).classList.remove('hidden');
  };
});

/******** HELPERS ********/
function setupDrop(zone, input, cb) {
  zone.onclick = () => input.click();
  zone.ondragover = e => e.preventDefault();
  zone.ondrop = e => { e.preventDefault(); cb([...e.dataTransfer.files]); };
  input.onchange = () => cb([...input.files]);
}

function loadImage(file) {
  return new Promise(res => {
    const img = new Image();
    img.onload = () => res(img);
    img.src = URL.createObjectURL(file);
  });
}

/******** MSM ********/
const msmImages = new Map();
const msmXmls = [];

setupDrop(msmImgDrop, msmImgInput, files => {
  files.forEach(f => {
    msmImages.set(f.name.replace(/\.[^.]+$/, ''), f);
    const img = document.createElement('img'); img.src = URL.createObjectURL(f);
    msmImgPreview.appendChild(img);
  });
});

setupDrop(msmXmlDrop, msmXmlInput, files => {
  files.forEach(f => {
    msmXmls.push(f);
    const d = document.createElement('div'); d.textContent = f.name;
    msmXmlPreview.appendChild(d);
  });
});

msmExport.onclick = async () => {
  const zip = new JSZip();
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  for (const xf of msmXmls) {
    const xml = new DOMParser().parseFromString(await xf.text(), 'application/xml');
    const atlas = xml.querySelector('TextureAtlas');
    if (!atlas) continue;

    const imgBase = atlas.getAttribute('imagePath').split('/').pop().replace(/\.[^.]+$/, '');
    const imgFile = msmImages.get(imgBase);
    if (!imgFile) continue;

    const img = await loadImage(imgFile);
    const folder = zip.folder(imgBase);

    for (const s of xml.querySelectorAll('sprite')) {
      const n = s.getAttribute('n');
      const x = +s.getAttribute('x');
      const y = +s.getAttribute('y');
      const w = +s.getAttribute('w');
      const h = +s.getAttribute('h');
      const r = s.getAttribute('r') === 'y';

      canvas.width = r ? h : w;
      canvas.height = r ? w : h;
      ctx.clearRect(0,0,canvas.width,canvas.height);

      if (r) {
        ctx.save(); ctx.translate(canvas.width/2, canvas.height/2);
        ctx.rotate(-Math.PI/2);
        ctx.drawImage(img, x,y,w,h, -w/2,-h/2,w,h);
        ctx.restore();
      } else ctx.drawImage(img,x,y,w,h,0,0,w,h);

      folder.file(n+'.png', await new Promise(r=>canvas.toBlob(r)));
    }
  }

  download(zip);
};

/******** DOF ********/
let dofImage = null;
let dofMeta = null;

setupDrop(dofImgDrop, dofImgInput, f => {
  dofImage = f[0];
  dofImgPreview.innerText = dofImage.name;
});

setupDrop(dofMetaDrop, dofMetaInput, f => {
  dofMeta = f[0];
  dofMetaPreview.innerText = dofMeta.name;
});

dofExport.onclick = async () => {
  if (!dofImage || !dofMeta) return;

  const text = await dofMeta.text();
  const img = await loadImage(dofImage);
  const zip = new JSZip();
  const folder = zip.folder(dofImage.name.replace(/\.[^.]+$/, ''));

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const spriteBlocks = [...text.matchAll(/name:\s*(.+?)\n[\s\S]*?rect:[\s\S]*?x:\s*(\d+)[\s\S]*?y:\s*(\d+)[\s\S]*?width:\s*(\d+)[\s\S]*?height:\s*(\d+)/g)];

  for (const m of spriteBlocks) {
    const name = m[1].trim();
    const x = +m[2];
    const y = +m[3];
    const w = +m[4];
    const h = +m[5];

    canvas.width = w; canvas.height = h;
    ctx.clearRect(0,0,w,h);
    ctx.drawImage(img, x, img.height - y - h, w, h, 0,0,w,h);

    folder.file(name, await new Promise(r=>canvas.toBlob(r)));
  }

  download(zip);
};

function download(zip) {
  zip.generateAsync({type:'blob'}).then(b => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(b);
    a.download = 'sprites.zip';
    a.click();
  });
}
</script>
</body>
</html>
